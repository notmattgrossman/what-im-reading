<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual ASCII Pond</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #001122, #003355);
            color: #66aaff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 10px #66aaff;
            z-index: 20;
            pointer-events: none;
        }

        .instructions {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0.8;
            font-size: 14px;
            z-index: 20;
            pointer-events: none;
        }

        .main-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 20, 40, 0.3);
        }

        .pond-container {
            width: 100%;
            height: 100%;
            background: rgba(0, 30, 60, 0.1);
        }

        .pond {
            display: grid;
            grid-template-columns: repeat(120, 1fr);
            grid-template-rows: repeat(60, 1fr);
            gap: 0;
            cursor: crosshair;
            user-select: none;
            background: #002244;
            width: 100%;
            height: 100%;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            line-height: 1;
            transition: all 0.1s ease;
        }

        .sun {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #ffff66, #ffcc00);
            border: 3px solid #ffaa00;
            border-radius: 50%;
            cursor: move;
            box-shadow: 0 0 20px #ffff66;
            z-index: 10;
            top: 100px;
            right: 100px;
        }

        .sun::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(255, 255, 102, 0.6);
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 20;
        }

        .clear-btn {
            background: rgba(102, 170, 255, 0.2);
            border: 1px solid #66aaff;
            color: #66aaff;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .clear-btn:hover {
            background: rgba(102, 170, 255, 0.4);
            box-shadow: 0 0 10px rgba(102, 170, 255, 0.5);
        }

        .sun-info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
            z-index: 20;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="title">ðŸŒŠ Virtual ASCII Pond ðŸŒŠ</div>
    <div class="instructions">Click on the pond to create ripples! Drag the sun to change lighting direction.</div>
    
    <div class="main-container">
        <div class="sun" id="sun"></div>
        <div class="sun-info" id="sunInfo">Sun Angle: 45Â°</div>
        <div class="pond-container">
            <div class="pond" id="pond"></div>
        </div>
    </div>
    
    <div class="controls">
        <button class="clear-btn" onclick="clearPond()">Clear Pond</button>
    </div>

    <script>
        const POND_WIDTH = 120;
        const POND_HEIGHT = 60;
        const RIPPLE_SYMBOLS = [' ', 'â–‘', 'â–’', 'â–“', 'â–ˆ'];
        
        let pond = [];
        let ripples = [];
        let sunPosition = { x: 0.7, y: -0.7 }; // Normalized position around circle
        let isDraggingSun = false;
        let isDraggingPond = false;
        let lastMousePos = { x: 0, y: 0 };
        let dragVelocity = { x: 0, y: 0 };
        
        // Initialize pond grid
        function initPond() {
            const pondElement = document.getElementById('pond');
            pondElement.innerHTML = '';
            pond = [];
            
            for (let y = 0; y < POND_HEIGHT; y++) {
                pond[y] = [];
                for (let x = 0; x < POND_WIDTH; x++) {
                    pond[y][x] = 2; // Start with middle tone (â–’)
                    
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = 'â–’';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    pondElement.appendChild(cell);
                }
            }
            updateSunPosition();
        }
        
        // Update sun visual position (simplified for screen positioning)
        function updateSunPosition() {
            const sun = document.getElementById('sun');
            const sunInfo = document.getElementById('sunInfo');
            
            // Keep sun in a reasonable position on screen
            const x = Math.max(50, Math.min(window.innerWidth - 90, sun.offsetLeft || (window.innerWidth - 140)));
            const y = Math.max(50, Math.min(window.innerHeight - 90, sun.offsetTop || 100));
            
            sun.style.left = x + 'px';
            sun.style.top = y + 'px';
            
            // Calculate angle based on screen position
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const angle = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI;
            sunInfo.textContent = `Sun Angle: ${Math.round(angle)}Â°`;
            
            // Update normalized sun position for lighting calculations
            const maxDist = Math.min(centerX, centerY);
            sunPosition.x = (x - centerX) / maxDist;
            sunPosition.y = (y - centerY) / maxDist;
        }
        
        // Create ripple at position
        function createRipple(x, y, intensity = 4) {
            ripples.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 25,
                intensity: intensity,
                age: 0,
                maxAge: 200
            });
        }
        
        // Create V-shaped wake ripples when dragging
        function createWakeRipples(x, y, velX, velY) {
            const speed = Math.sqrt(velX * velX + velY * velY);
            if (speed < 0.5) return; // Only create wake if moving fast enough
            
            // Normalize velocity direction
            const dirX = velX / speed;
            const dirY = velY / speed;
            
            // Create perpendicular vectors for V-shape
            const perpX = -dirY;
            const perpY = dirX;
            
            // Create multiple wake ripples in V formation
            const wakeIntensity = Math.min(3, speed * 0.5);
            const wakeSpread = Math.min(3, speed * 0.3);
            
            for (let i = 0; i < 3; i++) {
                const offset = (i - 1) * wakeSpread;
                const wakeX = x + perpX * offset - dirX * i * 2;
                const wakeY = y + perpY * offset - dirY * i * 2;
                
                if (wakeX >= 0 && wakeX < POND_WIDTH && wakeY >= 0 && wakeY < POND_HEIGHT) {
                    ripples.push({
                        x: wakeX,
                        y: wakeY,
                        radius: 0,
                        maxRadius: 15 + i * 2,
                        intensity: wakeIntensity - i * 0.5,
                        age: 0,
                        maxAge: 150 + i * 20
                    });
                }
            }
        }
        
        // Calculate lighting effect based on sun position and ripple
        function calculateLighting(x, y, rippleIntensity, distance, rippleX, rippleY) {
            if (rippleIntensity === 0) return 2; // Base middle tone
            
            // Calculate the normal vector of the ripple at this point
            const dx = x - rippleX;
            const dy = y - rippleY;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            
            // Normalized surface normal (pointing away from ripple center)
            const normalX = dx / dist;
            const normalY = dy / dist;
            
            // Sun direction (normalized)
            const sunDist = Math.sqrt(sunPosition.x * sunPosition.x + sunPosition.y * sunPosition.y) || 1;
            const sunDirX = sunPosition.x / sunDist;
            const sunDirY = sunPosition.y / sunDist;
            
            // Calculate dot product for lighting (how much the surface faces the sun)
            const dotProduct = normalX * sunDirX + normalY * sunDirY;
            
            // Convert ripple intensity to height displacement
            const height = rippleIntensity / 4.0;
            
            // Calculate final lighting
            let lighting = 2; // Base middle tone
            
            if (height > 0) {
                // Highlight side (facing sun)
                if (dotProduct > 0) {
                    lighting = Math.min(4, 2 + (dotProduct * height * 2));
                } else {
                    // Shadow side (away from sun)
                    lighting = Math.max(0, 2 + (dotProduct * height * 1.5));
                }
            }
            
            return Math.round(lighting);
        }
        
        // Update all ripples
        function updateRipples() {
            // Reset pond to base state
            for (let y = 0; y < POND_HEIGHT; y++) {
                for (let x = 0; x < POND_WIDTH; x++) {
                    pond[y][x] = 0; // Will be calculated with interactions
                }
            }
            
            // Calculate ripple interactions at each point
            for (let y = 0; y < POND_HEIGHT; y++) {
                for (let x = 0; x < POND_WIDTH; x++) {
                    let totalDisplacement = 0;
                    let activeRipples = [];
                    
                    // Check all ripples affecting this point
                    ripples.forEach(ripple => {
                        const dx = x - ripple.x;
                        const dy = y - ripple.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check if point is within ripple's influence
                        if (distance <= ripple.radius + 2) {
                            const baseIntensity = ripple.intensity; // Remove age-based decay
                            
                            // Calculate wave displacement at this point
                            let displacement = 0;
                            
                            if (distance <= ripple.radius + 1.5 && distance >= ripple.radius - 1.5) {
                                // Main wave ring
                                const ringDistance = Math.abs(distance - ripple.radius);
                                const ringIntensity = baseIntensity * (1 - ringDistance / 1.5);
                                
                                // Create sine wave for smooth oscillation
                                const phase = (ripple.age * 0.2) + (distance * 0.5);
                                displacement = ringIntensity * Math.sin(phase);
                            }
                            
                            // Secondary smaller ripples for realism
                            if (distance <= ripple.radius - 2 && ripple.radius > 5) {
                                const innerRingDistance = Math.abs(distance - (ripple.radius - 4));
                                if (innerRingDistance <= 1) {
                                    const innerIntensity = baseIntensity * 0.3 * (1 - innerRingDistance);
                                    const innerPhase = (ripple.age * 0.15) + (distance * 0.4);
                                    displacement += innerIntensity * Math.sin(innerPhase);
                                }
                            }
                            
                            if (Math.abs(displacement) > 0.1) {
                                totalDisplacement += displacement;
                                activeRipples.push({
                                    ripple: ripple,
                                    displacement: displacement,
                                    distance: distance,
                                    dx: dx,
                                    dy: dy
                                });
                            }
                        }
                    });
                    
                    // Calculate final intensity with interaction effects
                    let finalIntensity = 2; // Base middle tone
                    
                    if (activeRipples.length > 0) {
                        // Convert total displacement to visual intensity
                        let rippleIntensity = Math.abs(totalDisplacement);
                        
                        // Enhanced interaction effects
                        if (activeRipples.length > 1) {
                            // Calculate interference patterns
                            let constructiveInterference = 0;
                            let destructiveInterference = 0;
                            
                            for (let i = 0; i < activeRipples.length; i++) {
                                for (let j = i + 1; j < activeRipples.length; j++) {
                                    const disp1 = activeRipples[i].displacement;
                                    const disp2 = activeRipples[j].displacement;
                                    
                                    // Check if waves are in phase (constructive) or out of phase (destructive)
                                    if ((disp1 > 0 && disp2 > 0) || (disp1 < 0 && disp2 < 0)) {
                                        constructiveInterference += Math.abs(disp1 * disp2) * 0.5;
                                    } else {
                                        destructiveInterference += Math.abs(disp1 * disp2) * 0.3;
                                    }
                                }
                            }
                            
                            // Apply interference effects
                            rippleIntensity += constructiveInterference;
                            rippleIntensity = Math.max(0, rippleIntensity - destructiveInterference);
                            
                            // Boost interaction zones for visibility
                            if (activeRipples.length >= 2) {
                                rippleIntensity *= 1.2;
                            }
                            if (activeRipples.length >= 3) {
                                rippleIntensity *= 1.3;
                            }
                        }
                        
                        // Calculate lighting based on strongest ripple
                        let strongestRipple = activeRipples.reduce((prev, current) => 
                            Math.abs(current.displacement) > Math.abs(prev.displacement) ? current : prev
                        );
                        
                        if (rippleIntensity > 0.2) {
                            finalIntensity = calculateLighting(x, y, rippleIntensity, 
                                strongestRipple.distance, strongestRipple.ripple.x, strongestRipple.ripple.y);
                                
                            // Special effects for strong interactions
                            if (activeRipples.length >= 2 && rippleIntensity > 2) {
                                // Create "foam" effect at intersection points
                                finalIntensity = Math.min(4, finalIntensity + 1);
                            }
                        }
                    }
                    
                    pond[y][x] = Math.max(0, Math.min(4, Math.round(finalIntensity)));
                }
            }
            
            // Update ripple ages and keep all ripples (no removal)
            ripples.forEach(ripple => {
                ripple.age++;
                ripple.radius += 0.1;
                // Ripples continue indefinitely - no maxAge limit
            });
        }
        
        // Render pond to screen
        function renderPond() {
            const cells = document.querySelectorAll('.cell');
            
            for (let y = 0; y < POND_HEIGHT; y++) {
                for (let x = 0; x < POND_WIDTH; x++) {
                    const cellIndex = y * POND_WIDTH + x;
                    const cell = cells[cellIndex];
                    const intensity = Math.min(4, Math.max(0, pond[y][x]));
                    
                    cell.textContent = RIPPLE_SYMBOLS[intensity];
                    
                    // Color based on intensity and lighting
                    if (intensity === 4) {
                        cell.style.color = '#ffffff';
                        cell.style.textShadow = '0 0 5px #ffffff';
                    } else if (intensity === 3) {
                        cell.style.color = '#ccddff';
                        cell.style.textShadow = '0 0 3px #ccddff';
                    } else if (intensity === 2) {
                        cell.style.color = '#7799cc';
                        cell.style.textShadow = 'none';
                    } else if (intensity === 1) {
                        cell.style.color = '#445588';
                        cell.style.textShadow = 'none';
                    } else {
                        cell.style.color = '#223344';
                        cell.style.textShadow = 'none';
                    }
                }
            }
        }
        
        // Animation loop
        function animate() {
            updateRipples();
            renderPond();
            requestAnimationFrame(animate);
        }
        
        // Get mouse position relative to pond
        function getMousePondPosition(event) {
            const pondElement = document.getElementById('pond');
            const rect = pondElement.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / (rect.width / POND_WIDTH));
            const y = Math.floor((event.clientY - rect.top) / (rect.height / POND_HEIGHT));
            return { x: Math.max(0, Math.min(POND_WIDTH - 1, x)), y: Math.max(0, Math.min(POND_HEIGHT - 1, y)) };
        }
        
        // Handle pond mouse events
        function handlePondMouseDown(event) {
            if (event.target.classList.contains('cell') && !isDraggingSun) {
                isDraggingPond = true;
                const pos = getMousePondPosition(event);
                lastMousePos = pos;
                createRipple(pos.x, pos.y);
                event.preventDefault();
            }
        }
        
        function handlePondMouseMove(event) {
            if (isDraggingPond) {
                const pos = getMousePondPosition(event);
                
                // Calculate velocity
                dragVelocity.x = pos.x - lastMousePos.x;
                dragVelocity.y = pos.y - lastMousePos.y;
                
                // Create wake ripples based on movement
                createWakeRipples(pos.x, pos.y, dragVelocity.x, dragVelocity.y);
                
                lastMousePos = pos;
            }
        }
        
        function handlePondMouseUp(event) {
            isDraggingPond = false;
        }
        
        // Handle sun dragging
        function handleSunDrag(event) {
            if (!isDraggingSun) return;
            
            // Simple screen-based positioning
            const x = Math.max(50, Math.min(window.innerWidth - 90, event.clientX - 20));
            const y = Math.max(50, Math.min(window.innerHeight - 90, event.clientY - 20));
            
            const sun = document.getElementById('sun');
            sun.style.left = x + 'px';
            sun.style.top = y + 'px';
            
            updateSunPosition();
        }
        
        // Clear all ripples
        function clearPond() {
            ripples = [];
        }
        
        // Event listeners
        document.getElementById('pond').addEventListener('mousedown', handlePondMouseDown);
        document.getElementById('pond').addEventListener('mousemove', handlePondMouseMove);
        document.getElementById('pond').addEventListener('mouseup', handlePondMouseUp);
        
        document.getElementById('sun').addEventListener('mousedown', (e) => {
            isDraggingSun = true;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', handleSunDrag);
        document.addEventListener('mouseup', () => {
            isDraggingSun = false;
        });
        
        // Initialize everything
        initPond();
        animate();
    </script>
</body>
</html> 